#region Prolog
#****Begin: Generated Statements***
#****End: Generated Statements****

#--------------- Constants ---------------#
cUserID 		= TM1USER();
cUser 			= NumberToString(DIMIX('}Clients', cUserID));
cTimeStamp  	= TimSt( Now, '\Y\m\d\h\i\s' );
cRandomInt  	= NumberToString( INT( RAND( ) * 1000 ));
sDelim 			= TRIM(pDimDelim);
sEleStartDelim 	= TRIM(pEleStartDelim);
sEleDelim 		= TRIM(pEleDelim);
cTemp 			= 0;
cLog 			= 'PLog';

#--------------- Prolog Variables ---------------#
pView			  = 'Test';
sSubset           = pView;
sDelimDim         = TRIM(pDimDelim);
sElementStartDelim= TRIM(pEleStartDelim);
sDelimElem        = TRIM(pEleDelim);
pSubN			  = 1;

## LogOutput parameters
nErrors = 0;

### Validate Parameters ###

## Default filter delimiters
If( pDimDelim     @= '' );
    pDimDelim     = '&';
EndIf;
If( pEleStartDelim@= '' );
    pEleStartDelim= 'Â¦';
EndIf;
If( pEleDelim     @= '' );
    pEleDelim     = '+';
EndIf;


# Reset all of the subsets that may be attached to the view in the case that dimensions not in the filter
If( ViewExists( pCube, pView ) = 1 );
    ### Reset View ###
    sMessage = 'Resetting view ' | pView | ' on cube ' | pCube;
    nCount = 1;
    While( TabDim( pCube, nCount ) @<> '' );
        sCubeDimName = TabDim( pCube, nCount );
        # Subset is the same name as the view (no way to test if subset assigned, assume it is if same name)
        If( SubsetExists( sCubeDimName, sSubset ) = 1 );
            # Add all elements
            If( SubsetIsAllSet(sCubeDimName, sSubset, 1) <> 1 );
                sMessage = Expand('Unable to add all elements on subset %sSubset% in dimension %sCubeDimName%');
                nErrors = nErrors + 1;
            EndIf;
        EndIf;
        nCount = nCount + 1;
    End;
Else;
    ### Create View ###
    sMessage = Expand('Creating view %pView% in cube %pCube%');
    ViewCreate( pCube, pView, cTemp );
EndIf;

ViewExtractSkipCalcsSet( pCube, pView, pSuppressConsol );
ViewExtractSkipZeroesSet( pCube, pView, 1 );
ViewExtractSkipRuleValuesSet( pCube, pView, 1 );
# Fix of issue #141, https://github.com/cubewise-code/bedrock/issues/141
# If( pSuppressConsolStrings <> -1 );
#     ViewExtractSkipConsolidatedStringsSet( pCube, pView, pSuppressConsolStrings );
# EndIf;

### Split filter and create subsets ###
sFilter = TRIM( pFilter );
sParsedFilter = '';
nChar = 1;
nCharCount = LONG( sFilter );
sWord = '';
sLastDelim = '';
nIndex = 1;
# Add a trailing element delimiter so that the last element is picked up
If( nCharCount > 0 );
  sFilter = sFilter | sDelimElem;
  nCharCount = nCharCount + LONG(sDelimElem);
EndIf;

WHILE (nChar <= nCharCount);
    sChar = SUBST( sFilter, nChar, 1);

    # Used for delimiters, required for multiple character delimiters
    sDelim = '';
    nAddExtra = 0;

    # Ignore spaces
    IF (TRIM(sChar) @<> '' );

      ### Dimension Name ###

      # If the delimiter is more than 1 character peek ahead the same amount
      # Ignore the first character
      sDelim = sChar;
      nCount = LONG(sElementStartDelim) - 1;
      If( nCount > 0 & nChar + nCount <= nCharCount );
        # Add the extra characters
        sDelim = sDelim | SUBST( sFilter, nChar + 1, nCount);
        # Move to the end of the delimter
        nAddExtra = nCount;
      EndIf;

      If( sDelim @= sElementStartDelim );

        sChar = sDelim;

        If( sLastDelim @<> '' & sLastDelim @<> sDelimDim );
            sMessage = 'The name of a dimension must follow a dimension delimiter (' | sDelimDim | ')';
            nErrors = nErrors + 1;
        EndIf;

        sDimension = sWord;
        nOneDimEleAdded = 0;
        
        If( DimensionExists( sDimension ) = 0 );
            # The dimension does not exist in the model. Cancel process
            sMessage = 'Dimension: ' | sDimension | ' does not exist';
            nErrors = nErrors + 1;
        EndIf;

        ### Determine the dimension is a member of the cube ###
        nCount = 1;
        nDimensionIndex = 0;
        While( TabDim( pCube, nCount ) @<> '' );
            sCubeDimName = TabDim( pCube, nCount );
            If( sDimension @= sCubeDimName );
                nDimensionIndex = nCount;
            EndIf;
            nCount = nCount + 1;
        End;

        If( nDimensionIndex = 0 );
            # The dimension does not exist in the cube. Cancel process
            sMessage = 'Dimension: ' | sDimension | ' is not a member of: '| pCube | 'cube.';
            nErrors = nErrors + 1;
        EndIf;

        # Create the subset
        If( SubsetExists( sDimension, sSubset ) = 1 );
            SubsetDeleteAllElements( sDimension, sSubset );
        Else;
            SubsetCreate( sDimension, sSubset, cTemp );            
        EndIf;

        # Attach to the view
        ViewSubsetAssign( pCube, pView, sDimension, sSubset );
        
        #Add to the Parsed filter
        IF(sParsedFilter@='');
          sParsedFilter=sDimension;          
        Else;
          sParsedFilter=sParsedFilter|sDelimDim|sDimension;
        Endif;  

        nIndex = 1;
        sLastDelim = sChar;
        # Clear the word
        sWord = '';
      Else;

        # Reset extra chars
        nAddExtra = 0;

        ### Check both both dim delimiter and element delimiter ###
        nIsDelimiter = 0;

        ## Check dimension delimiter first
        # If the delimiter is more than 1 character peek ahead the same amount
        # Ignore the first character
        sDelim = sChar;
        nCount = LONG(sDelimDim) - 1;
        If( nCount > 0 & nChar + nCount <= nCharCount );
          # Add the extra characters
          sDelim = sDelim | SUBST( sFilter, nChar + 1, nCount);
          # Move to the end of the delimter
          nAddExtra = nCount;
        EndIf;

        If( sDelim @= sDelimDim );
          nIsDelimiter = 1;
          sChar = sDelim;
        Else;
          # Reset extra chars
          nAddExtra = 0;

          ## Check element delimiter

          # If the delimiter is more than 1 character peek ahead the same amount
          # Ignore the first character
          sDelim = sChar;
          nCount = LONG(sDelimElem) - 1;
          If( nCount > 0 & nChar + nCount <= nCharCount );
            # Add the extra characters
            sDelim = sDelim | SUBST( sFilter, nChar + 1, nCount);
            # Move to the end of the delimter
            nAddExtra = nCount;
          EndIf;

          If( sDelim @= sDelimElem );
            nIsDelimiter = 1;
            sChar = sDelim;
          Else;
            # Reset extra chars
            nAddExtra = 0;
          EndIf;

        EndIf;

        If ( nIsDelimiter = 1 );

          If( sLastDelim @= '' % sLastDelim @= sDelimDim );
            sMessage = 'An element delimiter must follow a dimension name: ' |  sChar | ' (' | NumberToString(nChar) | ')';
            nErrors = nErrors + 1;
#             LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );
            #ProcessError();
          EndIf;

          sElement = sWord;

          If( DIMIX( sDimension, sElement ) = 0 );
              # The element does not exist in the dimension. Cancel process
              sMessage = 'Element: ' | sElement | ' in dimension ' | sDimension | ' does not exist';
              nErrors = nErrors + 1;
#               LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );
              #ProcessError();
          EndIf;
          
          sElement = DimensionElementPrincipalName(sDimension,sElement);

          If ( pSuppressConsol = 1 & DTYPE( sDimension, sElement) @= 'C'  );
              # Add all N level elements to the subset
              # Loop through all elements and check if it is an ancestor
              sMessage = 'Element ' | sElement | ' is consolidated' ;
#               IF ( pLogoutput = 1 );
#                 LogOutput( cMsgInfoLevel, Expand( cMsgInfoContent ) );
#               EndIf;
              nElCount = DIMSIZ ( sDimension );
              n = 1;
              WHILE ( n <= nElCount );
                  sEl = DIMNM( sDimension, n );
                  IF( DTYPE( sDimension, sEl) @<> 'C' & ELISANC( sDimension, sElement, sEl ) = 1 );
                      SubsetElementInsert( sDimension, sSubset, sEl, 0 );
                  EndIf;
                  n = n + 1;
              END;
              
              # Add the consolidated element to the subset as well to export strings, if necessary
#               If ( pSuppressConsolStrings = 0 );
#                 SubsetElementInsert( sDimension, sSubset, sElement, 0 );
#               EndIf;

          Else;
              # Add the element to the subset
              SubsetElementInsert( sDimension, sSubset, sElement, 0 );
          EndIf;
          
          #Add to the Parsed filter
          If( nOneDimEleAdded = 0 );
            sParsedFilter=sParsedFilter|pEleStartDelim|sElement;
            nOneDimEleAdded = nOneDimEleAdded + 1;
          Else;
            sParsedFilter=sParsedFilter|sDelimElem|sElement;
          EndIf;

          nIndex = nIndex + 1;
          sLastDelim = sChar;

          # Clear the word
          sWord = '';
        Else;
          sWord = sWord | sChar;
        EndIf;

      EndIf;

    EndIf;

    nChar = nChar + nAddExtra + 1;

END;
sBedrockViewCreateParsedFilter = sParsedFilter;

# creating N level subset for all dim not included in pFilter 
# useful when suppress consolidation is not on
If(pSubN = 1);
    
    nCountDimC = 1;
    While( TabDim( pCube, nCountDimC ) @<> '' );
        sDimC = TabDim( pCube, nCountDimC );
        sDimString = sDimC;
        
        # filters created by other bedrock processes skip spaces from dim names and between separators
        While(Scan(' ',sDimString)>0);
            sDimString = subst(sDimString, 1, Scan(' ',sDimString)-1)|subst(sDimString,Scan(' ',sDimString)+1,long(sDimString));
        End; 
        sTFilter = sFilter;
        While(Scan(' ',sTFilter)>0);
            sTFilter = subst(sTFilter, 1, Scan(' ',sTFilter)-1)|subst(sTFilter,Scan(' ',sTFilter)+1,long(sTFilter));
        End;
        
        # to make sure that the name of the dim is not part of the name of another dim
        If(Scan(pDimDelim|sDimString|pEleStartDelim, sTFilter)=0 & Scan(sDimString|pEleStartDelim, sTFilter)<>1);
            sProc   = '}bedrock.hier.sub.create';
            nRet    = ExecuteProcess( sProc,
                'pLogOutput', 0,
                'pDim', sDimC,
                'pHier', '',
                'pSub', sSubset,
                'pConsol', '',
                'pAttr', '',
                'pAttrValue', '',
                'pLevelFrom', 0,
                'pLevelTo', 0,
                'pExclusions', '',
                'pDelim', pEleDelim,
                'pAddToSubset', 0,
                'pAlias', '',
                'pTemp', 0
            );
            
#             IF(nRet <> 0);
#                 sMessage = 'Error creating the view from the filter.';
#                 nErrors = nErrors + 1;
#                 LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );
#                 If( pStrictErrorHandling = 1 ); 
#                     ProcessQuit; 
#                 Else;
#                     ProcessBreak;
#                 EndIf;
#             ENDIF;
            
            ViewSubsetAssign( pCube, pView, sDimC, sSubset );
        
        EndIf;
        
        nCountDimC = nCountDimC + 1;
    End;

  EndIf;
#endregion
#region Metadata
#****Begin: Generated Statements***
#****End: Generated Statements****
#endregion
#region Data
#****Begin: Generated Statements***
#****End: Generated Statements****
#endregion
#region Epilog
#****Begin: Generated Statements***
#****End: Generated Statements****
#endregion